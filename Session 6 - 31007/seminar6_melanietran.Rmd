---
title: "Seminar 6 - MSCA 31001"
author: "Melanie Tran"
date: "11/7/2020"
output: html_document
---

```{r setup, include=FALSE}
dataPath <- setwd('/Users/meltra02/Desktop/MSCA/Quarter 1/31007 - Stats Analysis/Session 6 - 31007/Seminar 6')

```

*2. The Data Structure*
```{r, include = FALSE}
#Load the optimization package that will be needed for calculations and the data.
library(nloptr)# package for nonlinear optimization


dataMatrix <- as.matrix(read.table(file=paste(dataPath,'MiningTraining2016.csv',sep="/"), sep = ","))
events <- dataMatrix[,1]
head(dataMatrix)
length(dataMatrix)
```
Each row represents one event: seismic signal going above the (noisy) background noise level.
The first column is the time past since the first event measured in microseconds.
The second column is 1 if at the time of that row there is a goafing event (roof collapse), also referred to as the main shock, and 0 otherwise.
```{r}
# change the time scale to minutes
events <- events/60000000
plot(events, c(1:length(events)), col = 'blue', 
     type="s",ylab="n_events",xlab="time (minutes)",
     lwd=2,xlim=c(0,max(events)),ylim=c(0,length(events)))
```
*3. Predicting Goafing Events*
**3.2 Estimating Parameters **
```{r}
#Define the grid.
#Important choices for making the grid are for the number of points in the sample of intensities n and for the number of events included in calculation of each intensity w.

dt <- 0.05
w <- 10 # experiment with window width to estimate intensity
n <- 50 # experiment with number of observations of intensity in the model
t0 <- ((n+w)*dt) # earliest time when regression can be fitted
i0 <- (findInterval(t0, events) + 1) # earliest event number 

```

```{r}
regression <- function(tc, logRate, regressionTimes, returnError){
# tc - time of collapse
# logRate - logarithm of intensity calculated at times t_i, i= 1,...,n
# regressionTimes - sequence (tc-t_i), i= 1,...,n
# returnError - logical flag, TRUE if function is used in a minimization procedure; then it returns mean-squared residual
#               if FALSE return coefficient p, the slope, of the model    
  
  logregressionTimes <- log(tc-regressionTimes)
  linModel <- lm(logRate ~ logregressionTimes)
  if(returnError){ #if we use this function in a minimization procedure
    err <- sqrt(mean(linModel$residuals^2))
    res <- err    
  }
  else{ #we will need the p coefficient after minimization
    p <- linModel$coefficients[2]
    names(p) <- NULL
    res <- p
  }
  return(res)
}
```




```{r}
CT <- c()
P <- c()
INT <- c()
TTS <- c()
index <- 1
 
for (i in i0:length(events)){
  
  currTime <- events[i]
  
  tGrid <- seq(currTime - t0 + dt, 
               currTime, by = dt)
  
  eventsGrid <- findInterval(tGrid, 
                             events)
 
  N <- length(tGrid)
 
  intensity <- eventsGrid[(w + 1):N] - eventsGrid[1:(N - w)]
  
  intensity <- intensity / (dt * w) # events per minute
  
  timeGrid <- tGrid[(N - n + 1):N] # timeGrid contains t_i, i=1,...n
  # Use pmax(x, 0.1) to avoid log(0)
  
  logIntensity <- log(pmax(intensity, 0.1))
  
  res <- nloptr(x0 = currTime + 1, 
                eval_f = regression, 
                lb = currTime + 0.1, 
                ub = currTime + 10, 
                opts = list("algorithm" = "NLOPT_LN_COBYLA", 
                            "xtol_rel" = 1e-04),
                logRate = logIntensity, 
                regressionTimes = timeGrid, 
                returnError=TRUE)
 
  tc <- res$solution
  p <- regression(res$solution, 
                  logIntensity, 
                  timeGrid, 
                  FALSE)
  int = log(res$objective) - p * log(timeGrid)
  int2 = (res$objective) / ((timeGrid)^p)
 
  CT[index] <- currTime
  P[index] <- p
  INT[index] <- intensity[length(intensity)]
  TTS[index] <- tc - currTime
  index <- index + 1
}
 
resTable <- data.frame(currTime = CT,
                       p = P,
                       intensities = INT,
                       timeToShock=TTS)
 
head(resTable, 15)
 

```



After fitting the regression with given tc find such value of tc that minimizes the mean-squared error.
Use nloptr() for optimization.
```{r}
res <- nloptr(x0=currTime+1, eval_f=regression, lb=currTime+0.1, ub=currTime+10, 
              opts=list("algorithm"="NLOPT_LN_COBYLA", "xtol_rel" = 1e-04),
              logRate=logIntensity, regressionTimes=timeGrid, returnError=TRUE)

```
After running nloptr() variable res$solution contains tc giving the minimum mean-squared error.Obtain the corresponding p coefficient.

```{r}

t_max <-pmax(currTime)
signalNA <- c()
for (t in resTable$currTime){
  if (t < (t_max - 2)) {
    signalNA <- c(signalNA, 0)
  } else if (t > (t_max - 2) & t < (t_max - 1)) {
    signalNA <- c(signalNA, 1)
  } else {
    signalNA <- c(signalNA, NA)
  }
}

```

```{r}

goaf_logmodelNA <- glm(formula = signalNA ~ p + intensities + timeToShock,family = binomial(link = 'logit'), data = resTable)
summary(goaf_logmodelNA)
 
model_cutoffNA <- 0.6

```



```{r}
source("Mining_connection.R")
```

```{r}

# global vars
incoming_signals_counter <- 0                                   # incoming signals event counter
outgoing_signals_counter <- 0                                   # outgoing signals event counter
BUF_SIZE <- 10000                                               # we create buffers in advance:
inc_signals <- data.frame(time=.POSIXct(rep(NA, BUF_SIZE)))     # dataframe for incoming signals 
out_signals <- data.frame(time=.POSIXct(rep(NA, BUF_SIZE)))     # dataframe for outgoing signals

eventMoments <- rep(NA, BUF_SIZE)         # time spans from i-th signal and the first signal in minutes, eventMoments[1] = 0 
initial_timestamp <- Sys.time()     # start-of-program timestamp
plot_timestamp <- initial_timestamp # we use plot_timestamp to draw the plot once in a second

# parameters for the simple solution 
W <- 0.5                # window size for intensity estimating
eventRate_barrier <- 10

new_event_handler <- function() {
  now <- Sys.time()
  if(incoming_signals_counter < 0.5){
    initial_timestamp <<- now
  }
  # time in minutes from the start of the stream 
  t <- as.double(difftime(now, initial_timestamp, unit='min'))
  # log event if necessary
  # message("EVENT at ", now)
  
  # update inc_signals dataframe (append last value):
  incoming_signals_counter <<- incoming_signals_counter + 1
  inc_signals[incoming_signals_counter,] <<- list(now)
  eventMoments[incoming_signals_counter] <<- t
  
  send_signal <- FALSE
  
  dt <- 0.05
  w <- 12 # experiment with window width to estimate intensity
  n <- 50 # experiment with number of observations of intensity in the model
  t0 <- ((n + w) * dt) # earliest time when regression can be fitted
  
  if(t > t0)
  {
    # tSet <- c(t - W, t) #current time interval (t_i-1,t_i) 
    X <- eventMoments[!is.na(eventMoments)]
    # eventsBeforeMoments <- findInterval(tSet, X)
    # intensity <- eventsBeforeMoments[2] - eventsBeforeMoments[1] #events number between "t-w" and "t"
    # intensity <- intensity/W # events per minute
    # send_signal <- (intensity > eventRate_barrier) & (outgoing_signals_counter <= 0)
    
    currTime <- t
    tGrid <- seq(currTime - t0 + dt, 
                 currTime, 
                 by = dt) # grid at t0
    
    eventsGrid <- findInterval(tGrid, X)
    
    N <- length(tGrid)
    
    intensity <- eventsGrid[(w + 1):N] - eventsGrid[1:(N - w)]
    
    intensity <- intensity / (dt * w) # events per minute
    
    timeGrid <- tGrid[(N - n + 1):N] # timeGrid contains t_i, i=1,...n
    # Use pmax(x, 0.1) to avoid log(0)
    
    logIntensity <- log(pmax(intensity, 0.1))
    
    res <- nloptr(x0 = currTime + 1, 
                  eval_f = regression, 
                  lb = currTime + 0.1, 
                  ub = currTime + 10, 
                  opts = list("algorithm" = "NLOPT_LN_COBYLA", 
                              "xtol_rel" = 1e-04),
                  logRate = logIntensity, 
                  regressionTimes = timeGrid, 
                  returnError = TRUE)
    
    p <- regression(res$solution,
                    logIntensity,
                    timeGrid,
                    FALSE)
    
    tc <- res$solution
    
    params <- data.frame('p' = p,
                         'intensities' = intensity[length(intensity)],
                         'timeToShock' = tc - currTime)
    
    predicted_signals <- predict(goaf_logmodelNA, params, type = 'response')
    
    if(any(predicted_signals >= model_cutoffNA)){
      send_signal = TRUE
      # outgoing_signals_counter <= 0
    }
    
  }
  
  if (send_signal) {
    # update out_signals dataframe (append last value):
    outgoing_signals_counter <<- outgoing_signals_counter + 1
    out_signals[outgoing_signals_counter,] <<- list(now)
    message('Time: ', currTime, 2, '. Probability of: ', predicted_signals)
  }
  
  Draw()
  
  return( send_signal )
}
 

```

```{r}
Draw <- function()
{
    now <- Sys.time();
    if (difftime(now, plot_timestamp, unit='sec') >= 1) {
        plot_timestamp <<- now;
        if (incoming_signals_counter > 0) {
            t <- difftime(inc_signals$time[1:incoming_signals_counter], initial_timestamp, unit='min');
            plot(x=t, y=1:length(t), 
                 xlim=c(0, difftime(now, initial_timestamp, unit='min')),
                 type='s', xlab='time (minutes)', ylab='n_events');
            
            if (outgoing_signals_counter > 0) {
                # draw outgoing signal (only the first one)
                abline(v=difftime(out_signals$time, initial_timestamp, unit='min')[1],
                       col='red', lwd=2);
            }
        }
    }
}

```



```{r}
# server options
host <- "datastream.ilykei.com";
port <- 30004;
login <- "melanietran@uchicago.edu";
password <- "YJRcOMnX";
stream_name <- "Mining";
catch_handler_errors <- TRUE;
# make connection with your personal handler
result <- Connect(host, port, login, password, stream_name, new_event_handler, catch_handler_errors);
```

```{r}
# remove empty values from buffers
inc_signals <- inc_signals[!is.na(inc_signals$time),]
out_signals <- out_signals[!is.na(out_signals$time),]
eventMoments <- eventMoments[1:incoming_signals_counter]
alarmTime <- as.double(difftime(out_signals[1], inc_signals[1] , unit='min'))
message("alarmTime = ", alarmTime)

# after all you can dump your data/results and analyze it later
dump(c("inc_signals", "out_signals", "result"), file = "results.txt")


```

```{r}

```

